```
OS 스레드 , 프로세스 차이 (멀티스레드와 멀티프로세스차이, PCB)
```

---

## 운영체제 (Operating System)

- HW 하드웨어와 SW 소프트웨어를 관리하는 역할

### 1) 운영체제의 역할 - (4)

**(1) CPU 스케줄링과 프로세스 관리** 

 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스 생성과 삭제 자원 할당 및 반환을 관리

**(2) 메모리 관리** 

 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 할지 관리 

**(3) 디스크 파일 관리**

  : 디스크 파일을 어떤 방법으로 보관할지 관리 

**(4) I/O 디바이스 관리** 

 : I/O 디바이스 (마우스, 키보드)와 컴퓨터 간 데이터 주고받는 것 관리 

### 2) 운영체제 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/c93960f3-0ed9-4578-aa1c-59323edac487/Untitled.png)

위의 형태가 **운영체제의 구조적 형태**이다.

**1) GUI/CLI**

- GUI : (그래픽 유저 인터페이스) 사용자와 전기 장치 상호작용 할 수 있도록 하는 사용자 인터페이스
- CLI : 그래픽이 아닌 명령어로 처리하는 인터페이스 (참고로 GUI 없이 CLI만 있는 리눅스 서버도 있다.) CLI = CUI

**2) 시스템콜 : 응용 프로그램에서 시스템 자원 사용하기 위해 커널에 어떤 동작 요청하는 수단** 

- 유저 프로그램이 운영체제의 서비스 받기 위해 커널 함수 호출 시 사용

**3) 커널 :** 운영체제의 중추적 역할. 시스템콜 인터페이스 제공

- 메모리 관리, 프로세스 관리, 장치 관리 등의 서비스 제공 역할 맡는다.
- 운영체제 속에 보호된 메모리 영역에 존재함

**4) 드라이버 :** 하드웨어 제어하기 위한 소프트웨어

---

들어가기 앞서, 

**→ 기본적으로 운영체제의 커널이 프로그램을 메모리에 올려 ‘프로세스’로 만들면, CPU가 이를 처리한다.**

**→ CPU는 그저 ‘메모리’에 올라와있는 프로그램들의 명령어를 실행할 뿐이다.** 

# 프로세스

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/3dfe36f0-b722-4590-be9b-f00060e74dd6/Untitled.png)

**⬛ 프로그램 | 정적인 개념**

- 저장 장치에 저장된 작업을 실행 할 수 있는 실행 파일

**⬛ 프로세스 | 동적인 개념**

- **프로그램(실행 파일)을 메모리에 올려 실행 중인 상태 = ‘프로세스’**
- 정적 프로그램이 운영체제의 PCB를 받아 메인 메모리에 적재되어 동적인 상태된
- 컴퓨터에서 실행 중인 프로그램

<aside>
💡 **→ 프로그램 : 구글 크롬(chrome.exe) 실행 파일**

**→ 프로세스 : 우리가 크롬 두 번 클릭해서 (메모리에 올라와 해당 프로그램이 실행 상태가 되면) ‘구글 프로세스’로 변환된 것이다.**

</aside>

### **⬛ 프로세스의 메모리 구조**

- 운영체제는 프로세스에 적절한 메모리를 할당하는데, 다음 구조를 기반으로 할당한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/4fffb490-08d8-46d8-bf13-31f66bd03d36/Untitled.png)

**1) 동적 영역 : 런타임 단계에서 메모리 할당받는 것** 

(1) 스택 : 지역 변수, 매개변수, 실행되는 함수에 의해 늘거나 줄어드는 메모리 영역 

(2) 힙 : 동적 할당되는 변수들 담음

**2) 정적 영역  : 컴파일 단계에서 메모리를 할당받는 것** 

(1) 데이터 영역 

- BBS segment : 전역 변수, static, const로 선언되어 있고, 0으로 초기화 또는 초기화 안된 변수들
- Data segment : 전역 변수, static, const 로 선언되어 있고, 0이 아닌 값으로 초기화된 변수들

(2) 코드 영역 : 프로그램 코드 담김

### **⬛ 프로세스의 상태**

- 프로세스는 여러 가지 상태 값을 갖는다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/57431f38-b82d-4538-9e0a-f3d80fa9e322/Untitled.png)

**1) 생성 상태 (New)**

- 프로그램이 메모리에 올라가 프로세스가 되고, 운영체제에 의해 PCB가 생성된다.

**2) 준비 상태 (Ready)**

- 프로세스가 생성되면 바로 CPU에 할당되는 게 아니라 준비 상태에 접어든다.
- 이때 PCB는 준비 큐에 들어가며 CPU에 할당될 때까지 자신의 차례를 기다린다.
- 준비 큐에서 어떤 프로세스가 실행 상태로 옮겨지는가는 ‘CPU 스케줄러’에 의해 관리된다.

         ***디스패치 (dispatch) :** CPU 스케줄러에 의해 준비 상태의 프로세스가 실행 상태로 되는 것 

**3) 실행 상태 (Running)**

- CPU 스케줄러에 의해 프로세스가 실행 상태가 되면 CPU를 할당받아 작업을 진행한다.
- 시분할 시스템의 경우 타임 슬라이스가 주어지기 때문에 이 시간동안 프로세스가 CPU를 사용할 수 있다.
- 만약 주어진 타임 슬라이스 동안 작업 완료하지 못하면 타임 아웃 (timeout) 즉, 인터럽트가 발생하며 실행 상태의 프로세스는 작업을 중단하고 다시 준비 상태가 된다.

**4) 대기 상태 (Blocked)**

- 만약 실행 중인 프로세스가 입출력 요청한 경우에는 CPU 작업을 중단하고 입출력을 처리해야 한다.  따라서 CPU는 입출력 관리자에게 입출력 요청을 하게 된다.
- 이떄 block 명령이 발생하며 프로세스는 입출력이 끝날 때까지 대기 상태가 된다.
- 입출력이 완료되면 인터럽트가 발생하고, 대기 상태의 프로세스는 바로 실행 상태가 되는 게 아니라 준비 상태가 된다.
- 프로세스 입출력이 완료된 시점에 이미 CPU를 할당 받고 실행 중인 프로세스가 있을 수 있기 때문이다. 그러므로 준비 큐에 들어가서 자기 차례를 기다린다.

**5) 완료 상태 (Exit)**

- 프로세스가 작업 모두 완료하면 종료 된다.
- 메모리에 적재되어있던 프로세스 정보와 PCB가 제거된다.

### **⬛ CPU 스케줄링**

- CPU가 유휴 상태가 될 때마다, 운영체제는 준비 큐에 있는 프로세스 중 하나를 선택해 실행해야 하며 이때, CPU 스케줄러가 어떤 프로세스를 싱행할지 선택하고 CPU에 할당해주는 역할을 한다.

**⬛ 디스패처 (Dispatcher)**

- CPU 스케줄러에 의해 선택된 프로세스에게 CPU 제어권을 넘기는 것
- 프로세스 레지스터를 적재하고 (문맥교환) , 커널 모드에서 사용자 모드로 전환시켜주며, 프로세스가 다시 시작할 때 사용자 프로그램이 올바른 위치를 찾도록 한다.

**⬛  디스패치 지연 시간 (Dispatch Latency)** 

- 디스패처가 하나의 프로세스를  정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연 시간이라고 하며, 문맥 교환 오버헤드에 해당

**⬛ CPU 스케줄링 결정 4가지 상황**

**1) 실행 → 대기 상태로 전환 (ex. I/O 발생)**

**2) 실행 → 준비 상태로 전환 (인터럽트 발생)**

**3) 대기 → 준비 상태로 전환 (ex. I/O 완료 시)**

**4) 종료 될 때**

→ 1, 4 번 상황에서 ‘비선점형 스케줄링’

→ 2, 3 번 상황에서 ‘선점형 스케줄링’

### **1) 선점형 스케줄링**

- 선점형 : 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식

장점 : CPU 처리 기간이 매우 긴 프로세스의 CPU 사용 독점 막을 수 있으므로 효율적

단점 : 잦은 문맥 교환으로 인한 오버 헤드 커질 수 있음

**(1) RR (Round Robin) 라운드 로빈**

- 프로세스마다 같은 크기의 CPU 시간을 할당
- 프로세스가 할당된 시간 내에 처리 완료 못하면 준비 큐 리스트 가장 뒤로 보내지고, CPU는 대기 중인 다음 프로세스로 넘어감
- 균등한 CPU 점유시간 보장하며, 시분할 시스템을 사용

**(2) SRT (Shortest Remaining Time) | = SRTF**

- SJT 스케줄링을 선점형으로 구현한 기법
- 가장 짧은 시간 소요되는 프로세스 먼저 수행
- 남은 시간 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점됨

**(3) 다단계 큐 (Multi Level Queue)**

- 작업들을 여러 종류의 그룹으로 분할, 여러 개의 큐를 이용하여 상위 단계 작업이 선점
- 각 큐는 자신만의 독자적인 스케줄링을 가짐

**(4) 다단계 피드백 큐 (Multi Level Feedback Queue)**

- 입출력 위주와 CPU 위주인 프로세스 특성에 따라 큐마다 서로 다른 CPU 시간 할당량 부여
- FCFS와 라운드 로빈 기법 혼합

### 2) 비선점형 스케줄링

- 비선점형 : 어떤 프로세스가 이미 CPU 점유 중이면 해당 프로세스가 CPU 반환 시까지 다른 프로세스는 CPU 점유 불가능한 스케줄
- 콘베이 현상 : 모든 프로세스에 대한 요구를 공정히 처리하지만, 긴 작업 종료시까지 짧은 작업 수행 프로세스도 대기해야 하는 현상

장점 : 필요한 문맥 교환만 일어나니 상대적으로 오버헤드 적다.

단점 : 프로세스의 배치에 따라 효율성 차이 많이 

**(1) FCFS (First Come First Served Scheduling)**

- 프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할

**(2) 최단 작업 우선 - SJF (Shortest Job First Scheduling)**

- CPU burst 시간이 가장 짧은 프로세스에게 제일 먼저 CPU 할당하는 방식

**(3) 우선순위 (Priority Scheduling)**

- 우선순위가 제일 높은 프로세스에게 CPU 할당

**(4) HRRN (Hightest Response Ratio Next Scheduling)**

- 짧은 작업과 대기 시간이 긴 작업의 우선순위를 높인다.
- SJF의 단점인 긴 작업과 짧은 작업의 과도한 불평등 보완한 기법이다.
- 한 프로세스가 CPU를 사용하면 작업 완성 시까지 실행하며, 대기 시간이 고려되어 긴 작업과 짧은 작업 사이의 불평등을 어느 정도 완화한다.

---

# PCB (Process Control Block)

### **⬛ PCB | 프로세스 제어 블록**

- 운영체제가 프로세스 제어하기 위해 정보를 저장해놓는 곳
- 프로세스의 상태 정보 저장하는 구조체
- PCB는 운영체제가 프로세스를 표현한 것
- 프로세스가 생성될 때마다 고유 PCB가 생성되며, 프로세스 종료되면 PCB는 제거된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/801ed0c0-ac2d-4af4-b4dc-028446164fc4/Untitled.png)

### **⬛ PCB의 구조 (= PCB에 저장되는 프로세스의 정보들)**

**1) 프로세스 ID (Process ID)** 

    **: 프로세스의 고유 ID**

**2) 프로세스 스케줄링 상태 (Process State)**

   **: ‘준비’, ‘일시중단’ 등 프로세스가 CPU에 대한 소유권 얻은 이후의 상태** 

**3) 프로그램 카운터 (Program Counter)**

    **: 현재 프로세스 다음에 실행될 명령어의 주소**

**4) CPU 레지스터 (CPU Register)** 

    **: 프로세스 실행하기 위해 저장해야 할 레지스터 정보** 

**5) CPU 스케줄링 정보(CPU Scheduling Information)** 

   **: 우선 순위, 최종 실행 시각, CPU 점유 시간 등 CPU 스케줄링에 필요한 정보**

**6) 계정 정보 (Accounting Information)** 

   **: 프로세스 실행에 필요한 CPU 사용량, 실행한 유저 정보**

**7) I/O 상태 정보 (I/O Status)** 

   **: 프로세스에 할당된 입출력 장치 목록**

**8) 포인터** 

   **: 부모 프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터 등** 

## 문맥 교환 (Context Switching)

### **⬛ 문맥 교환**

- **현재 CPU를 사용중인 프로세스의 CPU 제어권이 다른 프로세스로 이양되는 과정**

싱글 코어에서, 어떠한 시점에 실행되고 있는 프로세스는 1개이며 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와의 문맥 교환이 빠른 속도로 실행되고 있기 때문이다. 

<aside>
💡 현대 컴퓨터는 멀티 코어의 CPU를 갖지만, 문맥 교환에서는 싱글코어 기준으로 설명한다.

</aside>

### **⬛ 문맥 교환 일어나는 과정**

**⬛ 인터럽트** 

- 프로그램 실행 도중 예기치 않은 상황 발생할 경우, 현재 실행 중인 작업을 일시 중단하고, 발생된 상황을 우선 처리 후 실행 중이던 작업으로 복귀하여 이전 일을 계속 처리하는

→ IVT : 인터럽트 벡터 테이블 (ISR 주소 보관 테이블)

→ ISR : 인터럽트 서비스 루틴 (해당 인터럽트 처리 위한 코드)

**⬛ 유휴 시간** 

- CPU가 작업 없이 쉬는 상태

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/85954186-7f16-42b1-87b2-81e8c004858a/Untitled.png)

1) **[프로세스A]** 실행 도중에 ‘인터럽트 or 시스템콜’ 발생

2) PCB1에 **[프로세스A]**  정보 저장 후, PCB2의 상태 불러옴(로드)

3) **[프로세스B]** 를 실행

4) **[프로세스B]** 실행 도중 ‘인터럽트 or 시스템콜’ 발생

5) PCB2에 **[프로세스B]** 정보 저장 후, PCB1 상태 불러옴 (로드)

6) **[프로세스A]** 를 실행 

**⬛ 캐시 미스** 

- CPU가 참조하려는 데이터가 캐시 메모리에 없을 때 발생

**⬛ 문맥 교환에서의 ‘캐시 미스’ | 문맥교환에 드는 비용** 

- 문맥 교환이 일어날 때, 현재 프로세스의 메모리 주소에 대한 캐시가 제대로 클리어 되지 않은 상태로 새로운 프로세스가 시작될 경우, 해당 프로세스와는 관련 없는 데이터가 남아있게 되므로, 해당 주소를 참조할 때 캐시 미스가 발생할 수 있다.

**⬛ 스레드에서의 ‘문맥 교환’**

- 스레드는 스택 영역 제외한 모든 메모리를 공유하므로, 스레드의 문맥 교환은 프로세스 문맥 교환보다 더 비용이 적고 시간도 적게 걸린다.

---

# 스레드

### **⬛ 스레드**

- 프로세스가 할당받은 자원을 이용하는 ‘실행 흐름 단위’
- 프로세스의 자원을 공유하는 독자적 실행 단위
- 프로세스의 스택 영역 제외한 (힙, 데이터, 코드) 영역은 공유한다.

**1) 커널 레벨 스레드** 

- 커널에서 직접 관리하는 스레드
- 더 안정성이 보장된다.
- 스케줄링과 동기화 때문에 속도가 더 느리다.

**2) 유저 레벨 스레드** 

- 유저가 라이브러리를 통해 관리하는 스레드
- 스케줄링이나 동기화를 사용자가 직접 구현해야 한다.
- 커널이 스레드의 존재를 모르기 때문에 문맥 교환이 없고, 하나의 스레드가 커널에 의해 블락되면 전체 프로세스가 블락된다.
- 입출력의 경우 커널 레벨 스레드가 더 빠르다.

# 프로세스와 스레드 비교

### ⬛ **개념적 비교**

- 프로세스 : 프로그램을 메모리에 올려 실행 중인 상태
- 스레드 : 프로세스 안에서 실행되는 여러 흐름 단위

### ⬛ 메모리 영역 비교

- **프로세스는 운영체제로부터 각 프로세스 별로 별도의 메모리 영역을 할당받고,**
- **스레드는 프로세스 안에서 스택 제외한 (코드/데이터/힙) 부분을 서로 공유해 읽고 쓸 수 있는 공유 자원으로 가진다.**
- **프로세스는 자신만의 고유 공간과 자원을 할당받아 사용**하는데 반해,
- **스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**하는 차이가 존재함

### 1) **프로세스**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/176eafdd-8427-441c-bb6c-b892bcc421cb/Untitled.png)

- OS는 프로세스마다 독립된 메모리 영역 (코드/데이터/스택/힙) 구조로 할당한다.
- 각 프로세스마다 독립된 메모리 영역을 할당해주기 때문에 프로세스가 다른 프로세스의 변수나 자료에 접근할 수 없다.

### 2) 스레드

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/3be84faa-21ca-4930-aa5a-26295a2c63a9/Untitled.png)

- 스레드는 메모리를 서로 공유할 수 있다.
- 프로세스가 할당 받은 메모리 영역 내에서 스택 형식으로 할당된 메모리 영역은 따로 할당받고, (코드/데이터/힙) 형식으로 할당된 메모리 영역은 공유한다.
- 따라서 각 스레드는 별도의 스택은 가지고 있지만, 힙 메모리는 서로 공유해서 읽고 쓸 수 있게 된다.

---

# 멀티 프로그래밍/태스킹/프로세스/스레드 비교

### 멀티 프로그래밍

- 여러 프로그램이 동시에 실행될 수 있도록 하는 시스템

### 멀티 태스킹

- 하나의 CPU에서 여러 개의 작업을 처리
- 하나의 프로그램이 여러 작업을 동시에 실행되는 것처럼 보이도록 하는 시스템

### 멀티 프로세스

- 여러 개의 CPU가 동시에 사용되어 하나 이상의 프로그램을 병렬로 처리하는 것

### 멀티 스레드

- 하나의 프로세스 내에서 여러 실행 흐름이 동시에 진행될 수 있는 시스템

---

## 멀티 프로세스

- 여러 개의 프로세스(멀티 프로세스)를 통해 동시에 두 가지 일 수행할 수 있는 것
- 하나 이상의 일을 병렬로 처리 가능
- 특정 프로세스 일부에 문제 발생하더라도 다른 프로세스로 처리하면 되므로 신뢰성 높은 강점

### **장점**

- 메모리 공유 X. 동기화 문제 X
- 하나의 프로세스에 문제 발생해도, 해당 프로세스 죽는 것으로 끝날 뿐 다른 프로세스에 영향X

### 단점

- 문맥 교환 시 오버헤드 크다.
- 프로세스간 자원 공유가 없기 때문에 IPC를 별도로 사용해야 함 ****

---

### ⬛ IPC (Inter Process Communication)

- 프로세스는 독립적으로 실행된다.
- 이런 독립적 구조를 가진 프로세스들도 프로세스 간 통신을 해야 하는 상황이 있을 것이다.
- 이를 가능하게 해주는 것이 **IPC 통신**이다.
- IPC : 프로세스끼리 데이터 주고받고 공유 데이터 관리하는 매커니즘

### ⬛ **IPC의 종류**

**1) 익명 파이프 (unnamed PIPE)** 

- 두 프로세스를 연결하는 ‘파이프’를 통해 데이터를 읽기/쓰기 한다.
- 반이중 통신이라 한 프로세스는 쓰기만. 나머지는 읽기만 가능하다. (동시 X)
- 이름을 아는 부모-자식 관계에서만 사용 가능

**2) 명명된 파이프 (named PIPE) : FIFO**

- 이름을 모르는 프로세스와 통신을 위함
- 이름이 있는 파일을 이용해서 이름을 모르는 프로세스와의 통신이 가능하다.
- 하지만, 명명된 파이프 역시 읽기/쓰기 동시에 불가능하다.

**3) 메시지 큐 (Message Queue) :FIFO**

- 명명된 파이프처럼, FIFO 형태로 자료구조를 메모리 공간에 둬서, 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.
- 차이점:  명명된 파이프는 데이터의 흐름, 메시지 큐는 메모리 공간

→ 파이프와 메시지 큐는 ‘통신’ 을 통해 다른 프로세스 간 데이터를 주고받는다면,

→ 공유 메모리는 프로세스 간 메모리 영역을 공유를 지원하여 데이터를 주고받을 수 있다.

**4) 공유 메모리 (Shared Memory)**

- 두 프로세스 간 메모리 영역을 공유해서 사용할 수 있도록 허용해준다.
- 중개자 없이 곧장 메모리에 접근 가능해서 IPC 중 가장 빨리 작동함

**5) 소켓** 

- 네트워크 소켓 통신을 통해 데이터 공유를 한다.

**6) 메모리 맵**

- 공유 메모리처럼 메모리를 공유해준다. 현재 열려져 있는 파일을 공유하는 점에서 차이가 있습니다.
- 메모리 맵은 현재 열린 파일을 메모리에 매핑시켜 공유하는 방식이다.

**이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)**

---

## 멀티 스레드

- 한 프로세스 내의 작업을 여러 개의 스레드로 처리하는 기법
- 스레드끼리는 서로 자원을 공유하므로 효율성이 높다.

**1) 하나의 프로세스에 ‘멀티 스레드’ : 동시성 높임**

- 싱글 코어에서 멀티 스레드로 동시에 여러 작업 하는 것처럼 보이는 것

**2) 여러 프로세스에 ‘멀티 스레드: 병렬성 높임**

- 멀티 코어에서 실제로 여러 작업을 동시에 처리하는 것

### 장점

- 메모리 공유하기 때문에 시스템 자원 소모량 적다
- 문맥 교환 시 오버헤드 작다. 따라서 작업 처리 속도 빠르다.
- 스레드는 스택 제외 메모리를 공유하기 때문에 스레드간 통신 (ITC) 부담 적다

### 단점

- 스레드는 자원 공유를 하기 때문에 **동기화 문제 (병목 현상, 데드락)**가 생길 수 있다.

→ 이를 해결하려고 **뮤텍스, 세마포어 활용**함

- 하나의 스레드에 문제 발생 시, 그 스레드 포함하는 프로세스 전체에 영향
- 프로세스 밖에선 스레드 제어 불가능

### ⬛ 동기화 문제 (Synchronization Issue) 란?

- 스레드는 프레세스의 코드/데이터/힙 영역을 공유하므로,
- **여러 스레드가 함께 공유 변수 사용할 경우, 발생할 수 있는 충돌을 ‘동기화 문제’**라고 한다.
- 스레드의 스케줄링은 운영체제가 관리해주지 않기 때문에 프로그래머가 적절한 기법을 직접 구현해야 한다.따라서 멀티 스레드 사용 시에는 신중할 것,

---

## 멀티 프로세스 vs 멀티 스레드

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2aaace0-24ef-4ae8-bed4-d8cb2e34acd9/411a89d3-2176-47c4-b2b0-6c707f228c2e/Untitled.png)

**1) 멀티 스레드**

- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간 차지하고, 문맥 교환이 빠르다.
- 단, 동기화 문제와 하나의 스레드 장애가 전체 스레드 종료로 이어질 위험을 갖는다.

**2) 멀티 프로세스**

- 멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향 주지 않아 안정성 높지만,
- 멀티 스레드보다 많은 메모리 공간과 CPU 시간 차지한다.

---
