## **24.01.23 질문 정리**

**1) 페이징과 세그멘테이션 기법을 비교**

**2) 페이징에서 주소 변환을 할 때 TLB 를 사용하는데 뭔지, 왜 사용하는지**

**3) 스와핑이 무엇인지, 장단점에 대해 설명**

1. **장점 - 실행 대기 시간을 줄일 수 있어서, CPU 활용도를 높일 수 있다.** 
2. **단점 - 시스템이 종료되었을 때, 데이터가 손실되는 단점이 존재**

**4) 세그멘테이션을 사용해서 얻을 수 있는 이점과 한계**

**장점 - 힙과 스택 사이의 빈 영역을 물리 메모리에 올리지 않아도 돼서 효율적인 공간 사용이 가능**

**5) 페이지 교체가 언제 발생하고, 어떤 알고리즘이 있는지** 

**언제 - 페이지 폴트 발생시**

**6) 수련 - CPU가 요청한 작업에 대한 데이터가 메모리에 없을 때 일어나는 과정(페이지 폴트 과정)**

**7) 내부 단편화, 외부 단편화 뭔지 설명**

**8) 메모리가 고갈되면 일어나는 현상**

> **쓰레싱 - 페이지 폴트가 많이 일어나는 것.**
> 

> **스와핑 악순환이 발생 시, out of memory 로 판단해서 중요하지 않은 프로세스를 종료시킨다.**
> 

9**) 주소변환의 전체적인 과정(페이징)** 

**10) 세그먼트 테이블 base, limit 이유가 뭔지.**

**세그먼트 크기가 가변적이기 때문에 보호하기 위해서 두개를 사용**

**11) 요구 페이징이 뭔지**

**12) 메모리 효율적으로 사용하기 위해 필요한 페이지만 사용하자**

**13) 왜 운영체제가 메모리 관리를 해야하는지, 어떤 전략을 사용하는지 설명**

1. **커널 모드에서 실행중인 OS의 경우, 커널 영역이랑 유저 영역에 접근 가능하기 때문에 OS에서만 관리가 가능하다**
2. **전략 - 세그멘테이션, 페이징, 스왑공간 등**

### 추가 내용

---

present bit vs valid bit 의 차이

valid 비트 는 해당 영역에 접근이 가능한지 여부를 나타냄

present 비트  물리 메모리에 존재하는지를 나타냄

---

관련 질문 정리

### **✅ 가상 메모리 등장하게 된 이유는 무엇인가요 ?**

메인 메모리의 용량은 한정적입니다. 

기존에는 프로그램 전부를 메모리에 올려 실행을 하다보니, 물리 메모리보다 큰 용량의 프로그램을 실행할 수 없었습니다. 이러한 문제를 해결하기 위해서 가상 메모리 개념이 등장합니다.

즉, 프로세스의 모든 부분은 항상 필요한 것이 아니라서, 현재 실행에 **필요한 부분만을 메모리에 올림으로써** 해결하는 것입니다. 그리고 이러한 부분 단위는 페이지 단위가 일반적이기 때문에 이를 두고 **요구 페이징 기법**이라고도 부릅니다.

### ✅ 가상 메모리가 무엇인지 설명해주세요.

모든 프로세스에 메모리를 할당하기에는 메모리의 크기에 한계가 있어서 사용하는 방법입니다.

프로세스에서 사용하는 부분만 메모리에 올리고, 나머지는 디스크에 보관하는 기법을 가상메모리라고 합니다.

가상메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법입니다. 가상메모리가 없다면 실행되는 코드의 전부를 메모리에 올려야 하므로 메모리 용량보다 큰 프로그램을 실행할 수 없습니다.

가상메모리를 사용하면 동시에 많은 프로그램을 실행할 수 있고, 응답 시간을 유지하면서 CPU 이용률과 처리율을 높일 수 있습니다.

단점으로는 물리 메모리에서 전체 프로세스 올린 것보다는 속도가 느리다는 단점이 있습니다.

### ✅ **OS가 메모리 관리를 해야하는 이유에 대해 설명해주시고, 메모리 관리를 위해 어떤 전략을 사용하는지 설명해주세요.**

우선, 각각의 프로세스는 독립된 메모리 공간을 갖습니다. 따라서 각 프로세스는 다른 프로세스의 메모리 공간에 접근할 수 없습니다. 오로지 '운영체제'만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 영향을 받지 않습니다. 따라서 OS 만이 메모리를 관리할 수 있기 때문에 적절한 관리가 필요합니다.

가상메모리를 이용한 Swapping, 페이징 및 세그멘테이션 전략, 고정 길이 할당 / 가변 길이 할당, 압축 등의 방식으로 OS가 메모리 관리를 수행할 수 있습니다.

### ✅ **페이징과 세그멘테이션 기법을 비교해주세요.**

• **페이징 :** 프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리해서 메인 메모리에 불연속적으로 저장하는 방식입니다. 만약 프로세스가 13MB이고 페이지가 4MB라면, 한 페이지는 1MB가 됩니다. 프레임은 무조건 4MB로 분리했으므로 3MB의 '내부단편화'가 발생할 수 있습니다. (연속 할당 방식보다는 적게 발생합니다.)

**• 세그멘테이션 :** 프로세스를 가변적인 크기의 세그먼트로 분리하고 메모리에 적재합니다. 주로 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap으로 분리할 수 있습니다. 세그멘테이션 역시 '외부 단편화'가 발생합니다. 세그먼트 테이블의 limit는 페이지 테이블에는 없는데, 그 이유는 세그먼트 크기는 가변적이기 때문에 크기를 명시해야 해당 세그먼트에 대해서만 접근할 수 있기 때문입니다.

### **✅ 페이징과 세그멘테이션의 차이는?**

페이징과 세그멘테이션 모두 프로그램을 실행하기 위해 디스크에 있는 내용을 분할하여 메모리에 적재하는 불연속 메모리 관리 기법이다. 둘의 차이는 프로그램을 분할하는 방식이다. 페이징의 경우 프로그램을 같은 크기의 페이지로 분할하는 데에 비해, 세그멘테이션은 논리적 의미를 기준으로 세그먼트를 분할한다.

### ✅ ***페이징 또는 세그멘테이션을 사용하는 이유는?***

프로그램을 실행하기 위해 코드를 디스크에서 메인 메모리로 적재하는 과정에서 단편화가 생길 수 밖에 없다. 이렇게 단편화가 많이 발생하면 사용하지 못하는 메모리 공간이 많아져 낭비가 되므로 최대한 피해야 한다. 최초 적합, 최적 적합, 압축 등의 방식을 통해 단편화를 해결할 수도 있지만, 메모리 계산의 비용이 적은 페이징 또는 세그멘테이션을 주로 사용한다.

### ✅ ***페이징의 특징은?***

페이징은 프로그램을 실행할 때, 코드를 메모리에 적재하기 위해 사용하는 기법이며, 불연속 메모리 관리 기법이라는 특징이 있다. 다시 말해 프로그램 전체가 메모리에 연속적으로 올라가 있는 것이 아니라 페이지라는 고정된 크기로 분할되어 올라가 있다. 또한, 페이징은 외부 단편화 문제를 해결할 수 있다.

### **✅ 페이징 기법이 무엇인가요 ?**

프로세스를 페이지 단위로 나누고, 메모리도 물리적인 frame 단위로 나누어서 관리하는 기법을 말합니다. 비연속 메모리 할당 기법의 대표적인 예시입니다.

연속적으로 메모리를 할당할 경우, `외부 단편화`라는 문제가 발생할 수 있습니다. 이것은 메모리에 남은 공간들은 있으나, 그 빈 공간이 마치 Hole처럼 흩어진 형태로 존재해서, 홀의 크기보다 더 큰 프로세스는 아무리 빈 공간이 있더라도 메모리에 적재될 수 없는 현상을 말합니다.

그래서 페이징 기법을 통해 페이지 단위로 나뉜 프로세스를 프레임에 적재하면, `외부 단편화` 문제는 해결되게 됩니다. 그러나 프레임 자체 안에 공간이 발생하게 되는 **내부 단편화 문제**가 발생할 수 있습니다.

(하지만 외부 단편화 문제를 해결하는 것이 성능에 더 이점이 있습니다.)

### **✅ 세그멘테이션이란 무엇인가요?**

페이징 기법이 물리적으로 크기가 고정된 page, frame 단위로 메모리를 나누었다면, 세그멘테이션은 프로세스를 **크기가 동적으로 변할 수 있는 단위인 세그먼트**로 나누는 것입니다.

세그먼트는 프로그램을 구성하는 서브 루틴, 프로시저, 함수나 모듈 등으로 구성됩니다. **즉, 각 세그먼트는 연관된 기능을 수행하는 하나의 모듈 프로그램으로 이해할 수 있습니다.**

그러나 세그멘테이션 방식은 세그먼트들을 단위로 해서 메모리에 적재하다 보니, 외부단편화가 발생할 수 있습니다.

### ✅ 내부 단편화, 외부 단편화가 무엇인지 설명해주세요.

단편화란, 프로세스들이 차지하는 메모리 사이에 사용하지 못할 만큼의 작은 공간을 의미합니다.

내부단편화란 하나의 메모리 영역이 적재하고자하는 프로세스보다 커서 할당 후 사용되지 않고 남게 되는 현상입니다.

외부단편화란 남아있는 총 메모리 공간이 요청한 프로세스 작업 공간보다 크지만, 남아있는 공간이 연속적이지 않아 할당하지 못하는 현상입니다.

### ✅ 요구 페이징이란 무엇인지 설명해주세요.

요구 페이징(Demand Paging)은 프로그램 실행 시작 시에 프로그램 전체를 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 의미합니다. 가상 메모리와 페이지 개념을 활용해 관리됩니다.

### ✅ 페이지 교체 언제 발생하고, 어떤 교체 알고리즘이 있는지 설명해주세요.

초기에 필요한 페이지들만 메인 메모리에 적재되어 있습니다. 

프로세스 동작 중, 필요한 페이지가 물리 메모리에 없는 상황을 페이지 부재(Page Fault)라고 하는데, 페이지 부재가 발생하면 원하는 페이지를 하드디스크의 Swap Space에서 가져오게 됩니다.

하지만 물리 메모리가 모두 사용중이라서 원하는 페이지를 물리 메모리에 적재하지 못한다면, 페이지 교체가 일어나게 됩니다.

- FIFO
    - 가장 오래된 페이지를 교체한다.
- OPT(Optimal)
    - 가장 먼 미래 동안 사용되지 않을 페이지를 교체한다.(불가능)
- LFU(Least Frequently Use)
    - 가장 사용 빈도가 적은 페이지를 교체한다.
- MFU(Most Frequently used)
    - 가장 사용 빈도가 많은 페이지를 교체한다.
- LRU(Least Recently Use)
    - 가장 오랫동안 사용되지 않은 페이지를 교체한다.
- NUR(Not Used Recently)
    - LRU와 유사한 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 교체한다.
    - 이를 확인하기 위해서 참조비트와 변형비트를 사용한다.
    - 참조 비트 : 페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1
    - 변형 비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1
    - 00인것이 가장 먼저 교체되버린다.

### ✅ 스레싱 (Thrashing)에 대해 설명해주세요.

페이지 부재율이 높은 상태를 의미합니다.

페이지 부재가 발생하면, 페이지 교체 혹은 페이지 로드가 일어납니다. 다양한 프로세스가 메모리에 올라오면서 메모리의 유효 사용 공간은 줄어들고, CPU의 가동 시간이 올라가면서 자원을 최대한 사용하게 됩니다.

그러나 메모리에 프로세스가 너무 많아지면, 프로세스당 물리 메모리를 사용할 수 있는 프레임의 개수가 줄어들고, 페이지가 물리 메모리에 적게 올라온 프로세스는 명령이 진행될 때 마다 Page Fault가 일어나 페이지 교체가 일어나게 됩니다. 이 경우엔 CPU 사용률이 줄어들게 됩니다.

페이지를 교체하는 과정에서는 CPU를 사용하지 않고, 페이지 교체만을 계속해서 실행하면, 운영체제는 CPU가 놀고 있으므로 더 많은 프로세스를 메모리에 올리려고 하며 악순환이 일어나게 됩니다. 이러한 현상을 Thrashing(쓰레싱)이라고 합니다.

이를 해소 하기 위해서 Working Set 알고리즘과 Page Fault Frequency 알고리즘을 사용합니다.

- Working Set : 대부분의 프로세스가 특정 페이지만 집중적으로 참조하는 특성을 이용, 일정 시간 동안 참조되는 페이지 개수를 파악하고, 그 페이지 수만큼 여분 프레임이 확보되면 그 때 페이지를 메모리에 올리는 알고리즘 입니다.
- Page Fault Frequency : Page Fault 퍼센트의 상한과 하한을 둡니다. 상한을 넘으면 페이지에게 지급하는 프레임 개수를 늘리고, 하한을 넘으면 지급 프레임 개수를 줄입니다.

또 CPU 사용률과 메모리 적재량을 함께 체크해야 쓰레싱 유무를 확인할 수 있게 됩니다.

### ✅ 메모리가 고갈되면 일어나는 현상에 대해 설명해주세요.

메모리가 고갈되었지만, 프로세스를 실행해야 하기 때문에 Swap이 활발해집니다. 따라서 CPU 이용률이 하락하고, OS는 CPU 이용률이 낮으므로 오히려 프로세스를 추가하게 되는 **쓰레싱 현상이 발생**합니다. 이를 해소하지 못하면 Out Of Memory 상태로 판단해 중요도가 낮은 프로세스를 강제로 종료하게 합니다.

### ✅ 메모리 할당 기법 중 (연속 방식, 불연속 방식)에 대해 설명해주세요.

**연속 할당 방식은, 프로세스 이미지가 분리되지 않은 온전한 프로세스를 메인 메모리에 적재하는 방식입니다. 연속 할당 방식에는 크게 2가지가 있으며 '고정 길이 할당'과 '가변 길이 할당'이 있습니다.**

- **고정 길이 할당 :** 메모리를 고정된 길이로 파트를 분리하고, 프로세스를 해당 파트에 삽입합니다. 고정된 길이의 파트 내에 프로세스가 들어가므로, 여백이 생길 수 있는데 이것을 '내부 단편화'라고 합니다.
- **가변 길이 할당 :** 메모리를 프로세스의 길이에 알맞게 파트를 분리하고, 해당 프로세스를 적재합니다. 가변된 길이이므로 내부 단편화는 발생하지 않지만, 가변적인 길이 할당에 의해 일부분이 남으므로 '외부 단편화'가 발생합니다.

**불연속 할당 방식은, 프로세스가 연속된 이미지가 아닌 분리된 이미지로 구성되어 메인 메모리에 적재하는 방식입니다. '페이징'과 '세그멘테이션' 방식이 있습니다.**

- 페이징 : 프로세스를 동일한 크기의 페이지로 분리, 메모리는 해당 페이지와 동일한 크기의 프레임으로 분리해서 메인 메모리에 불연속적으로 저장하는 방식입니다. 만약 프로세스가 13MB이고 페이지가 4MB라면, 한 페이지는 1MB가 됩니다. 프레임은 무조건 4MB로 분리했으므로 3MB의 '내부단편화'가 발생할 수 있습니다. (연속 할당 방식보다는 적게 발생합니다.)
- 세그멘테이션 : 프로세스를 가변적인 크기의 세그먼트로 분리하고 메모리에 적재합니다. 주로 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap으로 분리할 수 있습니다. 세그멘테이션 역시 '외부 단편화'가 발생합니다.

추가적으로 페이징과 세그멘테이션 방식은 연속적이지 않으므로, 각 조각이 실제 메모리의 위치에 있는지 알아야 하므로 **페이지/세그먼트 테이블**이 존재합니다.

---