## **메모리 계층**

### **Q. RAM을 주기억장치라고 표현하는 이유는 무엇인가요?**

컴퓨터가 어떠한 프로그램을 실행하는 동작에 대해 설명해보겠다.

먼저 보조기억장치에서 주기억장치로 프로그램을 불러온다.(부팅, 로딩)

주기억장치에서 프로그램을 기억하고 CPU와 통신할 준비가 끝나면 CPU에서 데이터를 주고받으며 프로그램을 구동한다. (동작, 구동)

따라서 컴퓨터 입장에서는 RAM은 작업실, CPU는 작업자와 같은 역할을 하게 된다. 이런 역할 때문에 주기억장치라고 표한한다.

### **Q. 지역성에 대해 설명해 주세요.**

- **지역성** : 데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것
    - **시간적 지역성(Temporal locality)** : 특정 데이터가 한 번 접근되었을 경우,가까운 미래에 또 한 번 데이터에 접근할 가능성이 높음
    - **공간적 지역성(Spatial locality)** : 액세스 된 기억장소와 인접한 기억장소가 액세스 될 가능성이 높음

### **Q. 왜 불편하게 전원이 차단되면 모든 기억된 내용이 지워지는 휘발성 장치를 사용할까요?**

아직 휘발성 특성, 단점을 가진 기계적 부품 이외에는 주기억장치의 역할을 할 부품이 상용, 양산화가 힘들기 때문이다.

빠른 속도와 효율을 제공해주기 때문에 휘발성임에도 불구하고 사용된다. 만일 기술의 발전으로 다른 방법이 생기면 이러한 단점이 사라질 수도 있다.

---

## ❓ Swapping 이란 무엇인가요?

- 메모리의 관리를 위해 사용되는 기법입니다.
- CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치(하드디스크)로 내보내고 다른 프로세스를 메모리로 불러 들이는 것을 의미합니다.
- swap-in: 주 기억장치(RAM)으로 불러오는 과정
- swap-out: 보조 기억장치로 내보내는 과정
- swap에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할 때 Swapping이 시작됩니다.

## ❓ Swapping을 하면서 발생하는 문제점에 대해 설명해주세요.

- 단편화(Fragmentation) 문제
    - 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 메모리 사이에 사용 하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는데 이를 단편화라고 합니다.
- 외부 단편화
    - 메모리에서 프로세스 사이 사이 남는 공간들을 의미합니다.
- 내부 단편화
    - 프로세스가 사용하는 메모리 공간에서 남는 부분을 의미합니다.
    
    ## ❓ 외부 단편화를 해소하기 위한 방법은 무엇이 있을까요?
    
    - 압축
        - 외부 단편화를 해소하기 위해 프로세스가 사용하는 메모리 공간들을 한쪽으로 몰아, 자유 공간을 확보하는 방법을 의미합니다.
        - 작업효율이 좋지 않아 잘 사용하지 않습니다.
    - 페이징 기법
        - 메모리 공간이 연속적이어야 한다는 제약을 없앱니다.
        - 물리 메모리를 Frame 이라는 고정 크기로 분리하고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리하는 기법입니다.
        - 이러한 페이징 기법을 통해 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있습니다.
        - 하나의 프로세스가 사용하는 공간을 여러 개의 페이지로 나뉘어서 논리 메모리에서 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장하는 방법입니다.
        - 하지만 페이지의 크기는 정해져 있기 때문에 내부 단편화는 발생할 수 있습니다.
    
    ## ❓ Segmentation 세그멘테이션이란 무엇입니까?
    
    - 프로세스를 물리적 크기의 단위가 아닌 논리적 내용의 단위인 세그먼트로 분할하고 메모리를 할당하며 주소를 변환하는 기법을 의미합니다.
    - 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법입니다.
    - 세그먼트의 단위가 다르기 때문에 메모리에 서로 다른 크기를 가진 여러 세그먼트를 저장할 시 외부 단편화가 생기는 문제점이 존재해 잘 사용하지는 않습니다.
    
    ---
    
    # 📌 Virtual Memory 가상 메모리
    
    ## ❓ 가상메모리에 대해 설명해주세요.
    
    - 가상 메모리는 프로세스가 실제 메모리의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술입니다.
    - 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있습니다.
    - 실제 메모리(RAM, main memory, first storage)와 보조 기억 장치(auxiliary storage, secondary storage)의 Swap 영역으로 구성되어 있습니다.
    - OS는 메모리 관리자(Memory Management Unit)를 통해 메모리를 관리합니다.
    - 프로세스는 사용하는 메모리가 실제 메모리인지, Swap 영역인지 모릅니다.
    - Java 에서는 Swap 영역을 잡아주지 않은 경우 OOM(Out Of Memory)이 발생할 수 있습니다.
    - Swap 영역은 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며, 가급적이면 Swap 메모리를 사용하지 않도록 설계하는 것이 좋고, 만약 계속해서 사용하는 양이 증가한다면 메모리 누수를 의심해 볼 수 있습니다.
    
    ## ❓ 가상 메모리가 탄생하게 된 배경에 대해 설명해주세요.
    
    - 실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었습니다.
    - 또한 멀티 프로세스상에서 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생했기 때문입니다.
    
    ### 메모리구조
    
    > 메모리에는 총 4가지의 구조가 있습니다.
    > 
    > 
    > 구조는 Code, Data, Heap, Stack 으로 구성되어 있습니다.
    > 
    > Code는 소스코드가 들어가는 부분이고,
    > 
    > Data는 전역변수, 정적변수가 할당되는 부분입니다.
    > 
    > 그리고,
    > 
    > Heap은 사용자가 직접 관리하는 영역으로 데이터가 동적으로 할당되는 공간입니다.
    > 
    > 마지막으로 Stack은 함수의 호출정보, 지역변수, 매개변수들이 저장되게 됩니다.
    > 
    
    ### 전역변수와 정적변수의 차이
    
    > 같은 점은,
    > 
    > 
    > 둘 다 프로세스가 죽을 때까지 유지되기 때문에 초기화가 필요하다는 것이고,
    > 
    > 다른점은,
    > 
    > 전역변수는 해당 프로그램(실행파일 기준)의 어느 함수, 어느 파일에서도 접근이 가능한 반면, 정적변수는 변수가 선언된 파일이나 함수내에서만 접근이 가능합니다.
    > 
    
    ### Heap, Stack 비교
    
    > 스택은 정적 메모리 구조를 가지고 힙 영역은 동적 메모리 구조를 가집니다.
    > 
    > 
    > 스택영역은,
    > 
    > - 함수 내에 정의된 지역 변수와 매개변수 등이 저장됩니다.
    > - 메소드 호출시 마다 각각의 스택프레임(그 메서드 만을 위한 공간)이 생성됩니다.
    > - 메소드 수행이 끝나면 프레임 별로 삭제됩니다.
    > - 프로그램에서 함수는 다른 함수를 호출하고 그 결과를 자신을 호출한 함수에 반환해줍니다.
    > - 따라서, 스택구조로 함수의 호출이 차곡차곡 메모리에 쌓이고 처리가 끝나면 메모리에서 해제됩니다.
    > - 이렇게 스택의 구조를 활용하여 함수의 지역 변수 메모리를 관리하면 위의 메커니즘을 쉽게 구현 할 수 있기 때문에 스택 형태로 영역을 만들어 활용합니다.
    > - 스택영역 (스택 세그먼트) 라고 부릅니다.
    > 
    > 힙 영역은,
    > 
    > - 관리가 가능한 데이터 외에 다른 형태의 데이터를 관리하기 위한 빈공간(Space) 입니다.
    > - 즉, 동적할당(Dynamic Allocation)에 의해 생성된 동적 변수(Dynamic Variables)를 관리하기 위한 영역입니다.
    > - 자바에서 new연산자로 생성된 객체와 배열을 저장하는 공간입니다.
    > - 클래스 영역에 로드된 클래스만 생성 가능합니다.
    > - GC(GarbageCollector)를 통해 메모리 반환합니다.
    > - java나 c++등에서 'new', c에서 'malloc', 'calloc' 을 통해 동적으로 생성되는 변수를 저장하기 위해 할당 되는 영역입니다.
    - 데이터 영역과 스택영역은 컴파일러가 미리 공간을 예측하고 할당할 수 있지만 **동적 변수는** 어느 시점에 어느정도의 공간으로 할당될 지 정확하게 예측할 수 없기 때문에 **프로그램 실행중(Runtime 시점)에 결정**됩니다.

## **[가상 메모리](https://bamtori.tistory.com/89#%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC-1)**

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법** 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

### **[가상 메모리 개발 배경](https://bamtori.tistory.com/89#%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B0%9C%EB%B0%9C%20%EB%B0%B0%EA%B2%BD-1)**

실행되는 **코드의 전부를 물리 메모리에 존재시켜야** 했고, **메모리 용량보다 큰 프로그램은 실행시킬 수 없었다.** 또한, 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생하게 된다. 또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램 전체가 메모리에 올라와 있어야 하는게 아니라는 것을 알 수 있다.