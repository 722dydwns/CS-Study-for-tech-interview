## 24.02.16 (금) 질문 내용 정리
---

1. **트랜잭션 개념과 특징에 대해서 설명하시오.**
2. **트랜잭션 병행 처리 했을 때 발생하는 문제와 방지하기 위한 방법에 대해 설명하시오.**
    1. **갱신손실 → 락킹 제어기법을 사용**
3. **Non-Repeatable Read 는 발생하지 않지만, Phantom Read는 발생하는 경우는? 그리고 각각 설명하세요.**
    1. **Non-Repeatable Read : 트랜잭션 내에서 같은 쿼리를 두번 실행 했는데 내용이 다른거**
    2. **Phantom Read : 같은 쿼리를 두 번 실행했는데 다른 트랜잭션의 `삽입` `삭제`로 결과가 다르게 나타나는 현상**
4. **트랜잭션 동작과정(hdd, buffer) : 물리적인 메모리 상의 동작 과정을 설명하시오.**
5. **데드락에 대해 설명, 데드락을 해결하기 위한 방법 3가지(낙관적 동시성 제어)에 대해 설명하시오.**
    1. **예방 기법, 회피 기법, 낙관적 동시성 제어**
6. **DB 락 종류 및 설명하시오.**
7. **격리 수준 SERIALIZABLE 하게 하는경우 장단점은 뭔가요 ?**
8. **락킹 단위를 크게 했을 때, 작게했을 때의 차이점과 락킹 제어가 일으킬 수 있는 문제점은 뭔가?**
    1. **단위를 크게했을 때, 동시성이 떨어진다**
    2. **너무 작으면, 관리가 어렵고 오버헤드가 증가한다. 병행성은 증가.**
    3. **문제점 : 데드락 발생할 수 있고, 동시성이 떨어진다**
9. **트랜잭션 격리수준에 대해 전반적인 내용을 설명하세요.**
10. **커밋과 롤백에 대해서 설명하세요.**

---

관련 질문 모음

### ✅ **DB 락에 대해 설명해주세요.**

DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법입니다.

공유락(LS, Shared Lock) Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다.

베타락(LX, Exclusive Lock) Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.

### ✅ 트랜잭션 에 대해 간단히 말해보세요.

하나의 논리적 기능을 수행하기 위한 작업의 단위로, 

DB의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.

### ✅ 트랜잭션 성질에 대해 말해주세요

A. ACID라 불리는 총 네가지 성질을 가지고있습니다.

- Atomicity는 트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이되지 않던지 둘중에 하나만 수행해야한다.(원자성)
- Consistency는 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야한다.(일관성)
- Isolation은 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.(독립성)
- Durablility는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.(영속성)

### ✅ 트랜잭션 병행으로 처리하려고 할 때 발생할 수 있는 문제를 설명해보세요.

- 갱신 내용 손실 : 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
- 현황 파악 오류 : 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
- 모순성 : 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
- 연쇄 복귀 : 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

### ✅ 트랜잭션 병행 처리 시 발생할 문제를 방지하기 위한 방법을 설명해주세요,

로킹 제어 기법을 사용한다.

어떤 트랜잭션이 특정 DB의 데이터를 사용할 때 DB의 일정부분을 Lock시키고 트랜잭션이 완료될때 해당부분을 Unlock시키는 방법이다. 종류는 크게 두가지가 있는데 공유 로킹은 Lock한 부분을 읽기는 가능하지만 쓰기는 불가능한 것이고 배타 로킹은 읽기,쓰기 둘다 불가능하게 한 것이다.

### ✅ 그렇다면 로킹 단위를 크게 했을 때와 작게 했을 때 차이점을 설명하시오.

로킹 단위가 크면 그만큼 관리가 쉽지만 병행성이 떨어진다. 로킹단위가 작으면 관리가 어렵고 오버헤드가 증가하지만, 병행성이 올라간다.

### ✅ 락킹 제어가 일으킬 수 있는 문제점은 무엇인가요 ?

로킹단위에 따라 다르겠지만 트랜잭션의 직렬화 가능성이 높아진다.(병행처리하나마나 할 수도있다.) 또 데드락이 발생할 수 있다.

### ✅ DB 상에 발생할 수 있는 데드락에 대하여 설명해보세요.

T1 : write(A) read(B)

T2 : read(B) read(A)

위와 같은 트랜잭션이 있다고 하면 T1은 A를 로킹해두고 B의 로킹해제를 기다려야하고 T2는 B를 로킹해두고 A를 기다려야한다. 이 때 두 트랜잭션이 무한정 대기해야하는 상황이 발생하는데 이것을 데드락이라고 한다. (해결방법 : 이 경우 T1, T2중 하나를 ROLLBACK하고 나머지 하나를 완료시킨 후 ROLLBACK한 트랜잭션을 다시 실행시킨다.)

### ✅ 그러면, 데드락을 안 생기게 하는 방법을 설명해보세요.

서비스 별로 해결하는 방법이 매우 다른데 일반적으로는 **데드락 탐지나 회피를 적용**시키면 된다.
**탐지인 경우 알고리즘을 통해 매번 데드락인지 아닌지 검사를 해야하므로 코스트가 크다.
회피인 경우 시분할 처리를하여 T1이 끝나면 T2가 실행시키게도 하면된다.**
Facebook 처럼 write 보다 read가 월등히 많은 경우 Read용 DB를 slave로 두고 로드를 모두 몰아주고 write를 Master로 보내고 DB를 동기화 할 수도 있다.

또 다른 해결 기법으론 로킹 제어기법이 아닌 타임스탬프 기법을 사용한다. 트랜잭션의 식별자로 타임스탬프를 지정하며 순서를 미리 선택한다. 트랜잭션이 대기하지 않고 바로 실행은 하나 높은 확률로 ROLLBACK이 일어나며 연쇄 복귀를 초래할 수 있다.

### ✅ COMMIT 과 ROLLBACK에 대해 설명해보세요.

COMMIT은 해당 트랜잭션으로 반영된 DB 변경사항을 ***저장*** 하는 것이고 ROLLBACK은 해당 트랜잭션으로 반영된 DB 변경사항을 ***취소*** 하는 것이고

### ✅ 데이터베이스 장애에 대해 설명하시오

- 트랜잭션 장애 : 트랜잭션을 정상적으로 완료하지 못함
- 시스템 장애 : 하드웨어, 소프트웨어 고장으로 인한 장애
- 디스크 장애 : 디스크 스토리지 일부 혹은 전체 붕괴로 인한 장애

### ✅ 데이터베이스 회복 기법에 대해 설명하시오.

- **로그기반 회복기법**
    - **지연 갱신 회복 기법**
        - write 연산 지연, 로그에 DB변경 내역 저장
        - 트랜잭션 완료시 로그를 보고 write 연산 수행
        - 트랜잭션 완료시 장애 발생 : REDO만 실행
        - 트랜잭션 미완료시 장애 발생 : 로그 무시
    - **즉시 갱신 회복 기법**
        - 즉시 DB 변경, 로그에 기록
        - 장애 발생 시 로그에 기반하여 UNDO 실행
- **체크포인트 회복기법**
    - 체크 포인트를 지정하여 장애발생 시 체크포인트까지 UNDO 실행 후 다시 REDO 실행
- **그림자 페이징 회복 기법**
    - 하드디스크에 그림자 페이지를 만들고 저장해두고 장애발생시 하드디스크에 있는 페이지로 주메모리 페이지 변경
    - 장애 미발생시 그림자 페이지 테이블은 삭제

### ✅ 데이터베이스에서 보통 작업을 추가/수정 할 때 어떤 식으로 하나요 ?

- Select나 Update 같은 SQL문 사용합니다.
- 보통 트랜잭션이라는 일련의 논리적 단위를 사용하게 됩니다.
- 예를 들어, 송금 작업을 한다고 치면 (계좌 1에서 돈 만원 뺴고, 계좌 2에 돈 만워을 넣는다) 처럼 하나의 작업 안에도 여러 SQL 문이 필요할 것입니다.
- 이런 요청이 여러 개 들어온다고 했을 때, 트랜잭션 별로 작업을 수행하지 않는다면, 작업이 뒤엉키게 된다.

### ✅ **트랜잭션을 병행 처리 시 문제가 발생하나요, 병렬 처리 시 문제가 발생하나요. 그리고 그때의 문제점을 말해보세요.**

**병행성 (Concurrency) : 동시성**  

**병렬성 (Parallelixm) : 순차적** 

레코드를 갱신할 때 다른 a의 트랜젝션이 롤백되고 b도 같이 롤백이 되는 상황이 일어날 수 있음

방지하기 위한 방법 : 특정 데이터베이스의의 데이터를 사용할 때 일부분을 LOCK을 걸고, 트랜젝션이 완료가 되면 LOCK을 풀고 다시 수행한다. (로킹제어기법)

로킹제어기법 사용했을 때 발생할 수 있는 문제 : 두개의 트랜젝션이 무한정 대기해야하는상태 (데드락)=>교착상태에 빠졌다

해결방법 : 하나 롤백시키고 롤백한거 완료하면 대기하고 있는거 실행 (로킹제어랑 똑같이)

### ✅ 트랜잭션에 대해 최대한 아는대로 설명해주세요.

데이터베이스의 상태를 변화시키기 위하여 , 논리적인 기능을 수행하는 하나의 작업단위 또는 한꺼번에 모두 수행되어야 하는 연산들

데이터베이스의 완전성을 보장하기 위한것이 목적

정상적으로 실행되었을 경우에는 commit이 이루어지고, 그렇지 않을 경우에는 rollback이 실행되면서

데이터베이스에는 아무런 영향을 끼치지 않음 (all or nothing)

**트랜잭션의 특성**

- 원자성(Atomicity) : 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 함
- 독립성(Isolation) : 실행중에 있는 연산의 중간 결과에 다른 트랜잭션이 접근할 수 없음
- 일관성(Consistency) : 실행을 성공적으로 완료하면 언제나 일관성있는 데이터베이스 상태로 변환함
- 지속성(Durability) : 일단 실행이 성공적으로 완료 되면 결과는 지속적이어야 함
- commit : 정상적으로 처리되어서 트랜잭션이 반영된 상태
- rollback : 취소하거나 정상적으로 이루어지지 않을 때 이전 상태로 돌아가는 것

### ✅ **교착상태 해결을 위한 3가지 방안과 방안별로 짧은 예시를 들어주세요**

교착상태 해결을 위한 방법으로 예방, 회피, 낙관적 병행제어가 있습니다. 예방은 트랜젝션 실행 전에 필요한 데이터를 모두 잠가 교착상태 자체를 예방합니다. 회피는 자원할당시 TimeStamp를 사용하여 교착상태를 피하는 방법입니다. 세부적으로 다른 트랜젝션이 데이터를 점유할 때 기다리거나 포기하는 Wait-Die 의 경우와 기다리거나 데이터를 빼앗는 방식인 Wound-Wait 방법이 있습니다. 낙관적 병행제어는 트랜잭션 실행시간동안 아무런 검사도 하지않고 트랜젝션이 모두 실행된 뒤에 검사하여 문제가 있다면 되돌리는 방법입니다.

### ✅ **트랜잭션의 특성(ACID)에 대해 설명해주세요**

원자성은 트랜잭션의 모든 연산이 정상적으로 수행 완료되어 모두 DB에 저장되거나 어떠한 연산도 수행되지 않아 DB에 전혀 반영되지 않아야 한다는 것입니다. 일관성은 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장하는 것입니다. 독립성은 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없는 것입니다. 지속성은 트랜잭션이 정상적으로 완료된 다음에는 영구적으로 DB에 작업의 결과가 저장되어야 한다는 것입니다.

### ✅ **DB에서의 Commit와 Rollback 이란?**

 Commit: 하나의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

 Rollback: 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 모든 연산을 취소(Undo)시키는 연산
