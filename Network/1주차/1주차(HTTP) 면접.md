스터디 1주차 | HTTP 관련 정리 

## **24.01.05 나온 질문 내용 공유**

1번. 세션 동작방식을 설명

2번. 쿠키와 세션의 특징 및 활용 사례

3번. 쿠키와 웹 스토리지의 차이점

4번. 쿠키를 전송 시 모든 정보가 전송되는지 - 서버의 경로에 따라 필요한 데이터를 선택해서 쿠키에 담는다.

5번. 브라우저에서 URL 에서 발생하는일

6번.  3-way-handshaking 의 각 과정의 이름과 의미

7번. 쿠키와 세션의 장단점

# HTTP

**✅ (실제질문) 쿠키와 세션 그리고 캐시의 차이점에 대해 알고있으신가요?**

- 쿠키는 웹사이트 접속 시 사용자의 브라우저에 저장되는 작은 텍스트 파일입니다. 그러므로 누구나 쿠키 값을 쉽게 확인 가능하므로 보안성이 낮습니다.
- 세션은 클라이언트가 아니라 서버에 저장하는 쿠기입니다. 쿠키의 보안성 을 개선한 방식입니다.
- 캐시는 리소스 파일들의 임시 저장소로 동일한 주소에 연속으로 request를 보내면 이전에 사용했던 결과를 로컬PC의에 임시 저장하여 다음번 호출할 때는 이것을 불러오는 것입니다.

**✅ HTTP 프로토콜의 특성 2가지에 대해 설명해주세요.**

- HTTP 프로토콜은 stateless, connectionless의 특징을 갖고 있습니다.

**1) 무상태성 stateless란,** 서버와 클라이언트 간 연결이 끊어지면 통신이 종료되고 상태 정보를 버린다는 특성입니다.

**2) 비 연결성 connectionless란**, 서버가 클라이언트로부터 요청을 받고 그에 맞는 응답을 주고 나면 서버에서 연결을 끊어 버리는 것을 말합니다. 

→ HTTP 1.1 Connection: Keep-Alive 옵션 이전에는 connectionless가 기본이었으나 keep-alive 옵션을 주면 연결을 유지할 수 있습니다.

**✅** **HTTP와 HTTPS에 대해서 설명해주세요**

HTTP는 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜이다. 가장 큰 특징은 Connectionless와 Stateless 이다. 그런데, HTTP는 평문 통신이기 때문에 도청이 가능하고 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 또한, 완전성을 증명할 수 없기 때문에 변조가 가능하다. 그래서 이것을 개선하기 위해 HTTPS 가 등장하게 되었다.

HTTPS 는 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜이다. 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다. SSL 을 사용하여 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

**✅ (실제질문) HTTP와 HTTPS의 차이점은 무엇인가요?**

HTTP와 HTTPS의 차이점은 데이터 암호화입니다. HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로채서 데이터를 확인 및 수정할 수 있습니다. 이를 보안적 측면에서 보완하기 위해 나온 것이 HTTPS입니다. 중간에 암호화 계층을 거쳐 패킷을 암호화하여 HTTP의 문제점을 개선했습니다.

**✅ HTTP와 HTTPS의 차이점에 대해 설명해주세요.**

- HTTPS(Hypertext Transfer Protocol Secure)
- 둘 다 웹 통신 프로토콜이지만, HTTPS는 HTTP의 기능에 **TLS**(Transport Layer Security) 혹은 **SSL**(Secure Sockets Layer)을 사용하여 암호화된 버전입니다. 일반적으로 보안이 중요한 통신에서는 HTTPS를 사용하는걸로 알고있고, HTTP는 80 port, HTTPS는 443 port를 사용하는 것으로 알고 있습니다.

# HTTPS (TLS,SSL)

**✅ HTTPS에 대해서 설명하고 SSL(TLS) Handshake에 대해서 설명해보세요** 

- HTTPS는 기존의 보안 이슈가 있던 HTTP에 보안을 강화한 프로토콜입니다.
- SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화합니다.

**TLS 핸드셰이크 설명**

- **기본적으로 서버가 CA에 공개키를 건네며 관리를 부탁하고, CA는 개인키를 이용해 서버의 공개키를 암호화 한 상태입니다.**

1) 클라이언트가 서버에게 tcp 연결을 위한 client hello 요청 + 클라이언트의 랜덤 데이터를 보낸다.

2) 서버가 클라이언트에 server hello 응답 + 인증서 + 서버의 랜덤 데이터를 보낸다. 

3) 클라이언트는 CA의 공개키를 이용해 받은 인증서를 복호화하여 서버 공개키를 얻게 된다.

4) 클라이언트는 서버와 클라이언트의 랜덤키를 조합해 pre master secret 키를 만들고, 공개키로 암호화해서 서버에 보낸다.

5) 서버가 개인키를 이용해 pre master secret키를 복호화하고, 이를 master secret 값으로 만든다.

6) 이 master secret 값으로 세션 키를 생성하고, 이 세션 키를 이용해서 이제 대칭키 방식의 통신을 한다.

**✅ 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요**

- **대칭키 : 암호화-복호화에 사용하는 키가 동일하다.**

//따라서 대칭키는 키 교환 와중에 탈취 위험이 있다.  이를 보완하려고 비대칭키 사용함

//A키로 암호화하면 A키로 복호화 된다.

- **비대칭키 : 암호화-복호화에 사용하는 키가 다르다.**

//A키로 암호화하면 B키로 복호화가 된다.

**✅ 왜 대칭키랑 비대칭키 두개를 혼합해써 쓰죠?**

- 대칭키는 빠르지만 보안에 취약한 부분이 있고,
- 비대칭키는 보안에 더 강하지만 비용 부담이 많이 들기 때문입니다.

# HTTP 1.1 2.0 3.0

**✅ HTTP 1.1 / 2.0 / 3.0 의 차이점에 대해서 설명해주세요**

HTTP 1.1 은 Pipelining이 특징이다. 기본적으로 HTTP 요청은 순차적이기 때문에 요청에 대한 응답을 받고 나서야 새로운 요청을 보낸다. 하지만 HTTP 1.1 에서는 응답을 기다리지 않고 요청을 연속적으로 보내는 기능이 추가되었다. 하나의 connection에서 한 번에 순차적인 여러 요청을 보내고 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄인다.

HTTP 2.0 은 Multiplexed Streams가 특징이다. HTTP 1.1 에서는 요청의 순서와 응답의 순서는 동기화 되어야 하므로 특정 요청을 처리하는데 많은 시간이 걸린다면 그 뒤의 다른 요청을 처리하는데 지연이 발생하여 HOL Blocking 이 발생한다. HTTP 2.0 은 하나의 Connection으로 동시에 여러 개의 메세지를 주고 받을 수 있다. 응답은 요청 순서에 상관없이 Stream 으로 받기 때문에 HOL Blocking 발생이 줄어든다.

HTTP 3.0은 TCP가 아닌 UDP를 사용한다는 것이다. HTTP 3.0 은 QUIC라는 프로토콜 위에서 돌아가는 HTTP인데, QUIC은 UDP를 사용하는 프로토콜이다. 그리고 TCP hand shake 과정을 최적화하는 것에 초점을 맞추어 설계되었다. UDP는 TCP에 비해 헤더가 많이 비어있기에, 커스터마이징할 수 있는 여지가 많고 이를 이용해 개발자가 구현을 어떻게 하느냐에 따라서 신뢰성을 확보할 수 있다.

**✅ (실제질문) HTTP 2.0과 1.1의 차이에 대해 알고있으신가요?**

http 1.1의 경우 기본적으로 연결 당 하나의 요청을 처리하도록 설계되었습니다. 그래서 동시 전송이 불가능하고 요청과 응답이 순차적으로 이루어지고 있습니다.

http 2.0의 경우 멀티플렉스 스트림 방식으로 한 커넥션으로 동시에 여러 개의 메세지를 주고 받을 수 있고 응답은 순서에 상관없이 스트림으로 주고받습니다.

****✅ HTTP를 버전 별로 설명해주세요****

**1) HTTP 1.0**

- **단기 커넥션(shrot-live connections)** : 요청 날릴때마다 커넥션 맺고 끊어짐

- Request를 날릴 때마다 Connection을 새로 생성해야 함
- Data를 압축해서 전달 가능하도록 하여 전달하는 Data 양이 감소

**2) HTTP 1.1**

- **지속 커넥션(Persistent connection)** : 커넥션 재사용 가능
- **HTTP 파이프라이닝(Pipelining)** : Request를 미리 여러 개 서버에 날릴 수 있음 (이전엔 리퀘스트 하나보내고, Response 받고, 그 다음 request 보내는 방식이었는데, 파이프라이닝 방식에서는 Request를 연속적으로 보내놓고 Reponse를 받는 방식)
- **단점 : Head Of Line Blocking**  => 요청한 Request에 문제가 생겨 응답이 늦어지면 그 다음 Request의 응답들도 같이 늦어짐

**3) HTTP 2.0**

- **Multiplexing :** 프레임 단위로 나눠서 전송 관리 가능하게 됨 **(다수의 요청과 응답이 가능한 구조)**
- **데이터 전송 방식 :** 바이너리로 인코딩하여 전송
- **ServerPush 사용** : 브라우저에서 필요한 리소스들을 서버가 알아서 찾아다가 내려주는 것
- 캐싱되지 않은 리소스를 받아올 때
- 페이지에서 필요한 리소스가 페이지를 내려주는 서버에 있을 때

**✅  HTTP 1.0와 HTTP 1.1의 차이점에 대해 말해주세요.**

> HTTP 1.0과 1.1의 가장 큰 차이점은 지속성입니다.
> 

HTTP 1.0은 **매 요청마다 새로운 TCP 연결을 열고, 응답 후에 닫는 형태**로 동작합니다. 매 연결마다 3-way handshake가 발생하며, 매번 새로운 연결을 설정하고 해제하는 비용이 들기 때문에 성능이 저하될 수 있습니다.

반면에 HTTP 1.1은 지속적인 연결을 지원합니다. **한 번의 TCP 연결이 이루어진 후에 연결을 유지**하며, 여러 요청과 응답을 처리합니다. 이로 인해 매번 연결을 만들고 해제하는 오버헤드가 감소하여 더 효율적이고 성능이 개선됩니다.

# HTTP RESTFUL

**✅REST란 무엇이고, RESTful하게 API를 디자인한다는 것은 무엇인지 설명하시오**

- REST란 ? URL을 통해 자원을 명시하고, HTTP 메소드를 통해 자원을 처리하도록 설계된 아키텍쳐
- RESTful : REST 아키텍쳐를 구현하는 웹 서비스를 디자인한 것
- RESTful API : **REST를 기반으로 서비스 API를 구현한 것**

**✅ "RESTful하다."의 의미가 무엇이라고 생각하시나요?**

- HTTP URI를 통해 자원을 표시하고 HTTP Method를 통해 자원에 대한 처리를 표현하는 것입니다.
- RESTful하게 설게된 API의 특징은 클라이언트가 읽고 URI에 이런 자원이 있겠다 그리고 어떤 요청이 필요하겠다라는 것을 이해할 수 있다는 것입니다.

**✅. (실제질문) REST API 통신의 프로토콜과 OSI 7계층 중 어디에 속하는지 설명해주세요**

HTTP 프로토콜을 사용하며 OSI의 응용 계층에 속합니다.

**✅ HTTP 메서드와 이것이 하는 역할에 대해서 설명해주세요.**

GET, POST, DELETE, PUT, PATCH가 대표적인 HTTP 메서드입니다.

GET은 서버에 존재하는 데이터를 요청하는 것입니다.

POST는 서버에 데이터 생성을 요청하는 것입니다.

PUT/PATCH는 서버에 데이터 수정을 요청하는 것입니다. PUT은 데이터 전체를 수정하고자할 때 사용하고 PATCH는 데이터 일부를 업데이트할 때 사용합니다.

DELETE는 서버에 데이터 삭제를 요청하는 것입니다.

**✅ GET과 POST의 차이점은 무엇인가요?**

GET은 서버에 존재하는 정보를 요청하는 것이고 POST는 서버에 정보 생성을 요청하는 것입니다. 일반적으로 GET은 Request Body를 사용하지 않고, URI 파라미터 또는 request parameter를 활용해서 사용하고 있습니다. 그리고 POST의 경우에는 생성하고자 하는 정보를 Request Body에 담아 전송합니다.

**✅ HTTP 메소드 종류와 사용법을 CRUD 관점에서 설명해주세요.**

먼저 Create를 위해 POST를 사용할 수 있습니다. 서버나 특정 리소스에 엔티티를 제출할 때 사용되는 메소드입니다. Read를 위해서는 GET을 사용할 수 있습니다. 특정 리소스의 표시를 요청하며, GET 요청은 오직 데이터 수신만 합니다. 다음으로 Update를 위해서는 PATCH, PUT, POST를 사용할 수 있지만 PATCH가 대표적입니다. 리소스의 일부를 수정할 수 있으며, PUT은 리소스 전체를 교체합니다. 마지막으로 Delete는 이름 그대로 DELETE 메소드를 사용해 특정 리소스를 삭제할 수 있습니다.

# HTTP 응답코드

**✅ HTTP 응답 코드 중 클라이언트 에러를 나타내는 401번과 403번의 차이점을 설명해 주세요.**

401번은 Unauthorized로, 클라이언트가 응답을 받기 위해 권한을 가진 사용자인지 인증할 필요가 있다는 의미입니다. 403번은 Forbidden로, 클라이언트가 콘텐츠에 접근할 권리가 없음을 의미합니다. 401과 다른 점은 이 때 서버는 클라이언트가 누구인지 알고 있다는 점입니다.